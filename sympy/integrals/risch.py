from sympy.core.add import Add
from sympy.core.mul import Mul
from sympy.core.symbol import Symbol, Wild
from sympy.core.basic import S, C, sympify
from sympy.core.numbers import Rational

from sympy.functions import exp, sin , cos , tan , cot , asin
from sympy.functions import log, sinh, cosh, tanh, coth, asinh

from sympy.functions import sqrt, erf

from sympy.solvers import solve

from sympy.polys import quo, gcd, lcm, \
    monomials, factor, cancel, PolynomialError, Poly, reduced
from sympy.polys.polyroots import root_factors

from sympy.utilities.iterables import make_list


#Zero = Poly(0, *V)

#One = Poly(1, *V)

def gcdexdiophantine(a, b, c):
    """
    Extended Euclidean Algorithm, Diophantine version.

    Given a, b in K[x], and c in (a, b), the ideal generated by a and b, return
    (s, t) such that s*a + t*b = c and either s = 0 or s.degree() < b.degree().
    """
    # Extended Euclidean Algorithm (Diophantine Version) pg. 13
    # XXX: This go in densetools.py
    # XXX: Bettter name?

    s, g = a.half_gcdex(b)
    q = c.quo(g) # Inexact division means c is not in (a, b)
    s = q*s

    if not s.is_zero and b.degree() >= b.degree():
        q, r = s.div(b)
        s = r

    t = (c - s*a).quo(b)

    return (s, t)

def derivation(p, D, x, t, coefficientD=False):
    """
    Computes the Dp, given the derivation D with D = d/dx and p is a polynomial
    in t over K(x).  If coefficientD is True, it computes the derivation kD
    (kappaD), which is defined as kD(sum(ai*Xi**i, (i, 0, n))) ==
    sum(Dai*Xi**i, (i, 1, n)) (Definition 3.2.2, page 80).
    """
    px = p.as_poly(x)
    if px is None:
        px = p.as_basic()

    if coefficientD:
        return px.diff(x).as_poly(t)
    return p.diff(t)*D + px.diff(x).as_poly(t)

def splitfactor(p, D, x, t, coefficientD=False):
    """
    Splitting factorization.

    Given a derivation D on k[t] and p in k[t], return (p_n, p_s) in k[t] x k[t]
    such that p = p_n*p_s, p_s is special, and each square factor of p_n is
    normal.

    Page. 100
    """
    One = Poly(1, t, domain=p.get_domain())
    Dp = derivation(p, D, x, t, coefficientD)
    if not p.has_any_symbols(t):
        s = p.as_poly(1/x).gcd(Dp.as_poly(1/x)).as_poly(t)
        n = p.quo(s)
        return (n, s)

    if not Dp.is_zero:
        h = p.gcd(Dp)
        g = p.gcd(p.diff(t))
        s = h.quo(g)

        if s.degree(t) == 0:
            return (p, One)

        q_split = splitfactor(p.quo(s), D, x, t, coefficientD)

        return (q_split[0], q_split[1]*s)
    else:
        return (p, One)

def splitfactor_sqf(p, D, x, t, coefficientD=False):
    """
    Splitting Square-free Factorization

    Given a derivation D on k[t] and p in k[t], returns (N1, ..., Nm)
    and (S1, ..., Sm) in k[t]^m such that p =
    (N1*N2**2*...*Nm**m)*(S1*S2**2*...*Sm**m) is a splitting
    factorization of p and the Ni and Si are square-free and coprime.
    """
    # TODO: This algorithm appears to be faster in every case
    S = []
    N = []
    p_sqf = p.sqf_list_include()
    for pi, i in p_sqf:
        Si = pi.as_poly(1/x, x).gcd(derivation(pi, D, x, t,
            coefficientD).as_poly(1/x, x)).as_poly(t)
        pi = Poly(pi, t)
        Si = Poly(Si, t)
        Ni = pi.quo(Si)
        if not Si.is_one:
            S.append((Si, i))
        if not Ni.is_one:
            N.append((Ni, i))

    return (tuple(N), tuple(S))

def canonical_representation(a, d, D, x, t):
    """
    Canonical Representation.

    Given a derivation D on k[t] and f = a/d in k(t), return (f_p, f_s, f_n) in
    k[t] x k(t) x k(t) such that f = f_p + f_s + f_n is the canonical
    representation of f (f_p is a polynomial, f_s is reduced (has a special
    denominator), and f_n is simple (has a normal denominator).
    """
    # Make d monic
    l = Poly(1/d.LC(), t)
    a, d = a.mul(l), d.mul(l)

    q, r = a.div(d)
    dn, ds = splitfactor(d, D, x, t)

    b, c = gcdexdiophantine(dn, ds, r)

    return (q, (b, ds), (c, dn))

def hermite_reduce(a, d, D, x, t):
    """
    Hermite Reduction - Quadratic version.

    Given a derivation D on k(t) and f = a/d in k(t), returns g, h, r in k(t) such
    that f = Dg + h + r, h is simple, and r is reduced.
    """
    # TODO: Rewrite this using Mack's linear version
    # Make d monic
    l = Poly(1/d.LC(), t)
    a, d = a.mul(l), d.mul(l)

    fp, fs, fn = canonical_representation(a, d, D, x, t)

    a, d = fn
    l = Poly(1/d.LC(), t)
    a, d = a.mul(l), d.mul(l)

    d_sqf = d.sqf_list()

    gn = Poly(0, t)
    gd = Poly(1, t)

    for v, i in d.sqf_list_include():
        if i < 2:
            continue

        u = d.quo(v**i)
        for j in range(i - 1, 0, -1):
            udv = u*derivation(v, D, x, t)
            b, c = gcdexdiophantine(udv, v, a.mul(Poly(-1/j, t)))

            gn = gn*v**j + b
            gd = gd*v**j
            a = c.mul(Poly(-j, t)) - u*derivation(b, D, x, t)

        d = u*v
    q, r = a.div(d)

    # TODO: review the proof to see if this is necessary
    g = gn.cancel(gd)
    gn, gd = g[1].mul(Poly(g[0], t)), g[2]

    rr = (q + fp + fs[0]).cancel(fs[1])
    rrn, rrd = rr[1].mul(Poly(rr[0], t)), rr[2]

    return ((gn, gd), (r, d), (rrn, rrd))

def polynomial_reduce(p, D, x, t):
    """
    Polynomial Reduction.

    Given a derivation D on k(t) and p in k[t] where t is a nonlinear monomial
    over k, return q, r in k[t] such that p = Dq  + r, and deg(r) < deg_t(Dt).
    """
    q = Poly(0, t)
    while p.degree(t) >= D.degree(t):
        m = p.degree(t) - D.degree(t) + 1
        q0 = Poly(t**m, t).mul(Poly(p.as_poly(t).LC()/(m*D.as_poly(t).LC()), t))
        q += q0
        p = p - derivation(q0, D, x, t)

    return (q, p)

def residue_reduce(a, d, D, x, t, z=None, invert=True):
    """
    Lazard-Rioboo-Rothstein-Trager resultant reduction.

    Given a derivation D on k(t) and f in k(t) simple, return g elementary
    over k(t) and a Boolean b in {True, False} such that f - Dg in k[t] if
    b == True or f + h and f + h - Dg do not have an elementary integral over
    k(t) for any h in k<t> (reduced) if b == False.

    Returns (G, b), where G is a tuple of tuples of the form
    (s_i, S_i), such that g = Add(*[RootSum(s_i, lambda z: z*log(S_i(z, t))) for
    S_i, s_i in G]). f - Dg is the remianing integral, which is elementary if
    and only if b == True, and hence the integral of f is elementary if and only
    if b == True.

    f - Dg is not calculated in this function because that would require
    explicitly calculating the RootSum.
    """
    p, a = a.div(d)
    z = z or Symbol('z', dummy=True)

    pz = Poly(z, t, z)

    Dd = derivation(d, D, x, t)
    q = a - pz*Dd

    if Dd.degree(t) <= d.degree(t):
        r, R = d.resultant(q, includePRS=True)
    else:
        r, R = q.resultant(d, includePRS=True)

    Np, Sp = splitfactor_sqf(r, D, x, t, coefficientD=True)
    H = []

    for s, i in Sp:
        if i == d.degree(t):
            s = Poly(s, z).monic()
            H.append((s, d))
        else:
            h = R[-i - 1]
            h_lc = Poly(h.as_poly(t).LC(), t, field=True)

            h_lc_sqf = h_lc.sqf_list_include(all=True)

            for a, j in h_lc_sqf:
                h = h.as_poly(t).quo(Poly(gcd(a, s**j, x, 1/x), t))

            s = Poly(s, z).monic()

            if invert:
                h_lc = Poly(h.as_poly(t).LC(), t, field=True)
                inv, coeffs = h_lc.as_poly(z).invert(s), [S(1)]

                for coeff in h.coeffs()[1:]:
                    T = reduced(inv*coeff, [s])[1]
                    coeffs.append(T.as_basic())

                h = Poly(dict(zip(h.monoms(), coeffs)), t)

            H.append((s, h))

    b = all([not cancel(i.as_basic()).has_any_symbols(t, z) for i, _ in Np])

    return (H, b)
