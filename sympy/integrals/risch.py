from sympy.core.add import Add
from sympy.core.mul import Mul
from sympy.core.symbol import Symbol, Wild
from sympy.core.basic import S, C, sympify
from sympy.core.numbers import Rational

from sympy.functions import exp, sin , cos , tan , cot , asin
from sympy.functions import log, sinh, cosh, tanh, coth, asinh

from sympy.functions import sqrt, erf

from sympy.solvers import solve

from sympy.polys import quo, gcd, lcm, \
    monomials, factor, cancel, PolynomialError, Poly
from sympy.polys.polyroots import root_factors

from sympy.utilities.iterables import make_list


#Zero = Poly(0, *V)

#One = Poly(1, *V)

def gcdexdiophantine(a, b, c):
    """
    Extended Euclidean Algorithm, Diophantine version.

    Given a, b in K[x], and c in (a, b), the ideal generated by a and b, return
    (s, t) such that s*a + t*b = c and either s = 0 or s.degree() < b.degree().
    """
    # Extended Euclidean Algorithm (Diophantine Version) pg. 13
    # XXX: This go in densetools.py
    # XXX: Bettter name?

    s, g = a.half_gcdex(b)
    q = c.quo(g) # Inexact division means c is not in (a, b)
    s = q*s

    if not s.is_zero and b.degree() >= b.degree():
        q, r = s.div(b)
        s = r

    t = (c - s*a).quo(b)

    return (s, t)

def derivation(p, D, x, t, coefficientD=False):
    """
    Computes the Dp, given the derivation D with D = d/dx and p is a polynomial
    in t over K(x).  If coefficientD is True, it computes the derivation kD
    (kappaD), which is defined as kD(sum(ai*Xi**i, (i, 0, n))) ==
    sum(Dai*Xi**i, (i, 1, n)) (Definition 3.2.2, page 80).
    """
    px = p.as_poly(x)
    if px is None:
        px = p.as_basic()

    if coefficientD:
        return px.diff(x).as_poly(t)
    return p.diff(t)*D + px.diff(x).as_poly(t)

def splitfactor(p, D, x, t, coefficientD=False):
    """
    Splitting factorization.

    Given a derivation D on k[t] and p in k[t], return (p_n, p_s) in k[t] x k[t]
    such that p = p_n*p_s, p_s is special, and each square factor of p_n is
    normal.

    Page. 100
    """
    One = Poly(1, t)
    Dp = derivation(p, D, x, t, coefficientD)
    if not p.has_any_symbols(t):
        s = p.gcd(Dp)
        n = p.quo(s)
        return (n, s)

    if not Dp.is_zero:
        h = p.gcd(Dp)
        g = p.gcd(p.diff(t))
        s = h.quo(g)

        if s.degree(t) == 0:
            return (p, One)

        q_split = splitfactor(p.quo(s), D, x, t, coefficientD)

        return (q_split[0], q_split[1]*s)
    else:
        return (p, One)

def splitfactor_sqf(p, D, x, t, coefficientD=False):
    """
    Splitting Square-free Factorization

    Given a derivation D on k[t] and p in k[t], returns (N1, ..., Nm)
    and (S1, ..., Sm) in k[t]^m such that p =
    (N1*N2**2*...*Nm**m)*(S1*S2**2*...*Sm**m) is a splitting
    factorization of p and the Ni and Si are square-free and coprime.
    """
    # TODO: This algorithm appears to be faster in every case
#    from pudb import set_trace; set_trace() # Debugging
    S = []
    N = []
    p_sqf = p.as_poly(t).sqf_list_include()
    for pi, i in p_sqf:
        Si = pi.gcd(derivation(pi, D, x, t, coefficientD))
        Ni = pi.quo(Si)
        if not Si.is_one:
            S.append((Si, i))
        if not Ni.is_one:
            N.append((Ni, i))

    return (tuple(N), tuple(S))

def canonical_representation(a, d, D, x, t):
    """
    Canonical Representation.

    Given a derivation D on k[t] and f = a/d in k(t), return (f_p, f_s, f_n) in
    k[t] x k(t) x k(t) such that f = f_p + f_s + f_n is the canonical
    representation of f (f_p is a polynomial, f_s is reduced (has a special
    denominator), and f_n is simple (has a normal denominator).
    """
    # Make d monic
    l = Poly(1/d.LC(), t)
    a, d = a.mul(l), d.mul(l)

    q, r = a.div(d)
    dn, ds = splitfactor(d, D, x, t)

    b, c = gcdexdiophantine(dn, ds, r)

    return (q, (b, ds), (c, dn))

def hermite_reduce(a, d, D, x, t):
    """
    Hermite Reduction - Quadratic version.

    Given a derivation D on k(t) and f = a/d in k(t), returns g, h, r in k(t) such
    that f = Dg + h + r, h is simple, and r is reduced.
    """
    # TODO: Rewrite this using Mack's linear version

    # Make d monic
    from pudb import set_trace; set_trace()
    l = Poly(1/d.LC(), t)
    a, d = a.mul(l), d.mul(l)

    fp, fs, fn = canonical_representation(a, d, D, x, t)

    a, d = fn

    d_sqf = d.sqf_list()

    gn = Poly(0, t)
    gd = Poly(1, t)

    for v, i in d.sqf_list_include():
        if i < 2:
            continue

        u = d.quo(v**i)
        for j in range(i - 1, 0, -1):
            udv = u*derivation(v, D, x, t)
            b, c = gcdexdiophantine(udv, v, a.mul(Poly(-1/j, t)))

            gn = gn*v**j + b
            gd = gd*v**j
            a = c.mul(Poly(-j, t)) - u*derivation(b, D, x, t)

        d = u*v
    q, r = a.div(d)

    # TODO: review the proof to see if this is necessary
    g = gn.cancel(gd)
    gn, gd = g[1].mul(Poly(g[0], t)), g[2]

    rr = (q + fp + fs[0]).cancel(fs[1])
    rrn, rrd = rr[1].mul(Poly(rr[0], t)), rr[2]

    return ((gn, gd), (r, d), (rrn, rrd))
