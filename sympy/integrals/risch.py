"""
The Risch Algorithm for transcendental function integration.

The core algorithms for the Risch algorithm are here.  The subproblem
algorithms are in the rde.py and prde.py files for the Risch
Differential Equation solver and the parametric problems solvers,
respectively.  Conventions here is that the base domain is QQ(x), and
each differential extension is t1, t2, ..., t. x is the variable of
integration (Dx == 1), D is a list of the derivatives of t1, t2, ..., t,
T is the list of t1, t2, ..., t, t is the outer-most variable of the
differential extension, k is the field Q(x, t1, ..., tn-1), where t ==
tn.  The numerator of a fraction is denoted by a and the denominator by
d.  If the fraction is named f, fa == numer(f) and fd == denom(f).
Fractions are returned as tuples (fa, fd).  d and t are often used to
represent the topmost derivation and extension variable, respectively.
The docstring of a function signifies whether an argument is in k[t], in
which case it will just return a Poly in t, or in k(t), in which case it
will return the fraction (fa, fd). Other variable names probably come
from the names used in Bronstein's book.
"""
from sympy.core.basic import S
from sympy.core.function import Lambda
from sympy.core.symbol import Symbol

from sympy.functions import log

from sympy.polys import (gcd, cancel, PolynomialError, Poly, reduced, RootSum)

#    from pudb import set_trace; set_trace() # Debugging

class NonElementaryIntegral(Exception):
    """
    Exception used by subroutines within the Risch algorithm to indicate to one
    another that the function being integrated does not have an elementary
    integral in the given differential field.
    """
    # TODO: Rewrite algorithms below to use this (?)
    pass

def gcdex_diophantine(a, b, c):
    """
    Extended Euclidean Algorithm, Diophantine version.

    Given a, b in K[x] and c in (a, b), the ideal generated by a and b,
    return (s, t) such that s*a + t*b = c and either s = 0 or s.degree()
    < b.degree().
    """
    # Extended Euclidean Algorithm (Diophantine Version) pg. 13
    # XXX: This should go in densetools.py.
    # XXX: Bettter name?

    s, g = a.half_gcdex(b)
    q = c.quo(g) # Inexact division means c is not in (a, b)
    s = q*s

    if not s.is_zero and b.degree() >= b.degree():
        q, s = s.div(b)

    t = (c - s*a).quo(b)

    return (s, t)

def derivation(p, D, x, T, coefficientD=False):
    """
    Computes Dp.

    Given the derivation D with D = d/dx and p is a polynomial in t over
    K(x), return Dp.  If coefficientD is True, it computes the derivation kD
    (kappaD), which is defined as kD(sum(ai*Xi**i, (i, 0, n))) ==
    sum(Dai*Xi**i, (i, 1, n)) (Definition 3.2.2, page 80).  X in this case is T,
    so coefficientD computes the derivative just with respect to x, with the
    elements of T treated as constants.

    x is the base variable in the differential extension, the variable of
    integration.  T is a list of the other variables in the extension.  D is a
    list of the derivatives of each element of t, such that for each D[i] is a
    polynomial in t[i] and a ratinoal function in t[:i].
    """
    t = T[-1]

    px = p.as_poly(x)
    if px is None:
        px = p.as_basic()

    if coefficientD:
        return px.diff(x).as_poly(t)

    p = Poly(p, *T)
    return sum([(d*p.diff(v)).as_poly(t) for d, v in zip(D, T)]) + px.diff(x).as_poly(t)

def get_case(d, x, t):
    """
    Returns the type of the derivation d.

    Returns one of {'exp', 'tan', 'base', 'primitive', 'other_linear',
    'other_nonlinear'}.
    """
    if not d.has(t):
        if d.is_one:
            return 'base'
        return 'primitive'
    if d.rem(Poly(t, t)).is_zero:
        return 'exp'
    if d.rem(Poly(1 + t**2, t)).is_zero:
        return 'tan'
    if d.degree(t) > 1:
        return 'other_nonlinear'
    return 'other_linear'

def splitfactor(p, D, x, T, coefficientD=False):
    """
    Splitting factorization.

    Given a derivation D on k[t] and p in k[t], return (p_n, p_s) in
    k[t] x k[t] such that p = p_n*p_s, p_s is special, and each square
    factor of p_n is normal.

    Page. 100
    """
    t = T[-1]

    One = Poly(1, t, domain=p.get_domain())
    Dp = derivation(p, D, x, T, coefficientD)
    for t in T:
        if p.is_zero:
            continue

        if not p.has_any_symbols(t):
            s = p.as_poly(1/x).gcd(Dp.as_poly(1/x)).as_poly(t)
            n = p.quo(s)
            return (n, s)

        if not Dp.is_zero:
            h = p.gcd(Dp)
            g = p.gcd(p.diff(t))
            s = h.quo(g)

            if s.degree(t) == 0:
                return (p, One)

            q_split = splitfactor(p.quo(s), D, x, T, coefficientD)

            return (q_split[0], q_split[1]*s)
    else:
        return (p, One)

def splitfactor_sqf(p, D, x, T, coefficientD=False):
    """
    Splitting Square-free Factorization

    Given a derivation D on k[t] and p in k[t], returns (N1, ..., Nm)
    and (S1, ..., Sm) in k[t]^m such that p =
    (N1*N2**2*...*Nm**m)*(S1*S2**2*...*Sm**m) is a splitting
    factorization of p and the Ni and Si are square-free and coprime.
    """
    # TODO: This algorithm appears to be faster in every case
    # TODO: Verify this and splitfactor() for multiple extensions
    t = T[-1]

    S = []
    N = []
    p_sqf = p.sqf_list_include()
    if p.is_zero:
        return (((p, 1),), ())

    for pi, i in p_sqf:
        Si = pi.as_poly(1/x, x).gcd(derivation(pi, D, x, T,
            coefficientD).as_poly(1/x, x)).as_poly(t)
        pi = Poly(pi, t)
        Si = Poly(Si, t)
        Ni = pi.quo(Si)
        if not Si.is_one:
            S.append((Si, i))
        if not Ni.is_one:
            N.append((Ni, i))

    return (tuple(N), tuple(S))

def canonical_representation(a, d, D, x, T):
    """
    Canonical Representation.

    Given a derivation D on k[t] and f = a/d in k(t), return (f_p, f_s,
    f_n) in k[t] x k(t) x k(t) such that f = f_p + f_s + f_n is the
    canonical representation of f (f_p is a polynomial, f_s is reduced
    (has a special denominator), and f_n is simple (has a normal
    denominator).
    """
    t = T[-1]

    # Make d monic
    l = Poly(1/d.LC(), t)
    a, d = a.mul(l), d.mul(l)

    q, r = a.div(d)
    dn, ds = splitfactor(d, D, x, T)

    b, c = gcdex_diophantine(dn.as_poly(t), ds.as_poly(t), r.as_poly(t))
    b, c = b.as_poly(t), c.as_poly(t)

    return (q, (b, ds), (c, dn))

def hermite_reduce(a, d, D, x, T):
    """
    Hermite Reduction - Quadratic version.

    Given a derivation D on k(t) and f = a/d in k(t), returns g, h, r in
    k(t) such that f = Dg + h + r, h is simple, and r is reduced.
    """
    t = T[-1]

    # TODO: Rewrite this using Mack's linear version
    # Make d monic
    l = Poly(1/d.LC(), t)
    a, d = a.mul(l), d.mul(l)

    fp, fs, fn = canonical_representation(a, d, D, x, T)

    a, d = fn
    l = Poly(1/d.LC(), t)
    a, d = a.mul(l), d.mul(l)

    d_sqf = d.sqf_list()

    gn = Poly(0, t)
    gd = Poly(1, t)

    for v, i in d.sqf_list_include():
        if i < 2:
            continue

        u = d.quo(v**i)
        for j in range(i - 1, 0, -1):
            udv = u*derivation(v, D, x, T)
            b, c = gcdex_diophantine(udv.as_poly(t), v.as_poly(t),
                a.mul(Poly(-1/j, t)).as_poly(t))
            b, c = b.as_poly(t), c.as_poly(t)

            gn = gn*v**j + b
            gd = gd*v**j
            a = c.mul(Poly(-j, t)) - u*derivation(b, D, x, T)

        d = u*v
    q, r = a.div(d)

    gn, gd = gn.cancel(gd, include=True)
    r, d = r.cancel(d, include=True)

    rrn = q + fp + fs[0]
    rrd = fs[1]
    rrn, rrd = rrn.cancel(rrd, include=True)

    return ((gn, gd), (r, d), (rrn, rrd))

def polynomial_reduce(p, D, x, T):
    """
    Polynomial Reduction.

    Given a derivation D on k(t) and p in k[t] where t is a nonlinear
    monomial over k, return q, r in k[t] such that p = Dq  + r, and
    deg(r) < deg_t(Dt).
    """
    t = T[-1]
    d = D[-1]
    q = Poly(0, t)
    while p.degree(t) >= d.degree(t):
        m = p.degree(t) - d.degree(t) + 1
        q0 = Poly(t**m, t).mul(Poly(p.as_poly(t).LC()/(m*d.as_poly(t).LC()), t))
        q += q0
        p = p - derivation(q0, D, x, T)

    return (q, p)

def residue_reduce(a, d, D, x, T, z=None, invert=True):
    """
    Lazard-Rioboo-Rothstein-Trager resultant reduction.

    Given a derivation D on k(t) and f in k(t) simple, return g
    elementary over k(t) and a Boolean b in {True, False} such that f -
    Dg in k[t] if b == True or f + h and f + h - Dg do not have an
    elementary integral over k(t) for any h in k<t> (reduced) if b ==
    False.

    Returns (G, b), where G is a tuple of tuples of the form (s_i, S_i),
    such that g = Add(*[RootSum(s_i, lambda z: z*log(S_i(z, t))) for
    S_i, s_i in G]). f - Dg is the remaining integral, which is
    elementary if and only if b == True, and hence the integral of f is
    elementary if and only if b == True.

    f - Dg is not calculated in this function because that would require
    explicitly calculating the RootSum.  Use residue_reduce_derivation().
    """
    # If r = residue_reduce(...), then the logarithmic part is given by:
    # sum([RootSum(a[0].as_poly(z), lambda i: i*log(a[1].as_basic()).subs(z,
    # i)).subs(t, log(x)) for a in r[0]])

    t = T[-1]
    z = z or Symbol('z', dummy=True)
    a, d = a.cancel(d, include=True)

    if a.is_zero:
        return ([], True)
    p, a = a.div(d)

    pz = Poly(z, t)

    Dd = derivation(d, D, x, T)
    q = a - pz*Dd

    if Dd.degree(t) <= d.degree(t):
        r, R = d.resultant(q, includePRS=True)
    else:
        r, R = q.resultant(d, includePRS=True)

    r = Poly(r, z)
    Np, Sp = splitfactor_sqf(r, D, x, T, coefficientD=True)
    H = []

    for s, i in Sp:
        if i == d.degree(t):
            s = Poly(s, z).monic()
            H.append((s, d))
        else:
            h = R[-i - 1]
            h_lc = Poly(h.as_poly(t).LC(), t, field=True)

            h_lc_sqf = h_lc.sqf_list_include(all=True)

            for a, j in h_lc_sqf:
                h = Poly(h, t, field=True).quo(Poly(gcd(a, s**j, x, 1/x), t))

            s = Poly(s, z).monic()

            if invert:
                h_lc = Poly(h.as_poly(t).LC(), t, field=True)
                inv, coeffs = h_lc.as_poly(z, field=True).invert(s), [S(1)]

                for coeff in h.coeffs()[1:]:
                    L = reduced(inv*coeff, [s])[1]
                    coeffs.append(L.as_basic())

                h = Poly(dict(zip(h.monoms(), coeffs)), t)

            H.append((s, h))

    b = all([not cancel(i.as_basic()).has_any_symbols(t, z) for i, _ in Np])

    return (H, b)

def residue_reduce_to_basic(H, x, T, z, Tfuncs):
    """
    Converts the tuple returned by residue_reduce() into a Basic expression.
    """
    # TODO: check what Lambda does with RootOf
    i = Symbol('i', dummy=True)
    return sum((RootSum(a[0].as_poly(z), Lambda(i, i*log(a[1].as_basic()).subs(
        {z: i}).subs(reversed(zip(T, [f(x) for f in Tfuncs]))))) for a in H))

def residue_reduce_derivation(H, D, x, T, z):
    """
    Computes the derivation of an expression returned by residue_reduce().

    In general, this is a rational function in t, so this returns an
    as_basic() result.
    """
    # TODO: verify that this is correct for multiple extensions
    i = Symbol('i', dummy=True)
    return S(sum((RootSum(a[0].as_poly(z), Lambda(i, i*derivation(a[1], D, x,
        T).as_basic().subs(z, i)/a[1].as_basic().subs(z, i))) for a in H)))

def integrate_hyperexponential_polynomial(p, D, x, T):
    """
    Integration of hyperexponential polynomials.

    Given a hyperexponential monomial t over k and p in k[t, 1/t], return q in
    k[t, 1/t] and a bool b in {True, False} such that p - Dq in k if b is True,
    or p - Dq does not have an elementary integral over k(t) if b is False.
    """
    from sympy.integrals.rde import rischDE

    t = T[-1]
    d = D[-1]

    D1 = D[:-1]
    T1 = T[:-1]
    if not D1:
        t1 = x
        T1 = [x]
        D1 = [Poly(1, x)]
    else:
        t = T1[-1]

    qa = Poly(0, t)
    qd = Poly(1, t)
    b = True
    for i in xrange(-p.degree(1/t), p.degree(t) + 1):
        if not i:
            continue
        elif i < 0:
            a = p.as_poly(1/t).nth(-i)
        else:
            a = p.as_poly(t).nth(i)

        aa, ad = a.as_numer_denom()
        aa, ad = aa.as_poly(t1), ad.as_poly(t1)
        iDt = Poly(i, t1)*d.quo(Poly(t, t)).as_poly(t1)
        iDta, iDtd = iDt.as_basic().as_numer_denom()
        iDta, iDtd = iDta.as_poly(t1), iDtd.as_poly(t1)
        try:
            va, vd = rischDE(iDta, iDtd, Poly(aa, t1), Poly(ad, t1), D1, x, T1)
        except NonElementaryIntegral:
            b = False
        else:
            qa = qa*vd + va*Poly(t**i)*qd
            qd *= vd

    return (qa, qd, b)

def integrate_hyperexponential(a, d, D, x, T, Tfuncs):
    """
    Integration of hyperexponential functions.

    Given a hyperexponential monomial t over k and f in k(t), return g
    elementary over k(t) and a bool b in {True, False} such that f - Dg in k
    if b is True or f - Dg does not have an elementary integral over k(t) if b
    is False.

    The function returns a Basic expression.
    """
    from pudb import set_trace; set_trace() # Debugging
    t = T[-1]
    z = Symbol('z', dummy=True)
    g1, h, r = hermite_reduce(a, d, D, x, T)
    g2, b = residue_reduce(h[0], h[1], D, x, T, z=z)
    if not b:
        return ((g1[0].as_basic()/g2[1].as_basic()).subs(reversed(zip(T, [f(x)
            for x in Tfuncs]))) + residue_reduce_to_basic(g2, t, z, tfunc))

    # p should be a polynomial in t and 1/t, because Sirr == k[t, 1/t]
    # h - Dg2 + r
    p = cancel(h[0].as_basic()/h[1].as_basic() - residue_reduce_derivation(g2,
        D, x, T, z).as_basic() + r[0].as_basic()/r[1].as_basic())
    p = Poly(p, t, 1/t)

    qa, qd, b = integrate_hyperexponential_polynomial(p, D, x, T)

    ret = (g1[0].as_basic()/g1[1].as_basic() + qa.as_basic()).subs(reversed(
        zip(T, [f(x) for f in Tfuncs])))/qd.as_basic().subs(reversed(zip(T,
        [f(x) for f in Tfuncs]))) + residue_reduce_to_basic(g2, x, T, z, Tfuncs)
    return (ret, b)

def integrate_hypertangent_polynomial(p, D, x, T):
    """
    Integration of hypertangent polynomials.

    Given a differential field k such that sqrt(-1) is not in k, a
    hypertangent monomial t over k, and p in k[t], return q in k[t] and
    c in k such that p - Dq - c*D(t**2 + 1)/(t**1 + 1) is in k and p -
    Dq does not have an elementary integral over k(t) if Dc != 0.
    """
    # XXX: Make sure that sqrt(-1) is not in k.
    t = T[-1]
    q, r = polynomial_reduce(p, D, x, T)
    a = derivation(t, D, x, T).quo(Poly(t**2 + 1, t))
    c = Poly(r.nth(1)/(2*a.as_basic()), t)
    return (q, c)

def integrate_nonlinear_no_specials(a, d, D, x, T, Tfuncs):
    """
    Integration of nonlinear monomials with no specials.

    Given a nonlinear monomial t over k such that Sirr = p in k[t] such
    that p is special, monic, and irreducible} is empty, and f in k(t),
    returns g elementary over k(t) and a Boolean b in {True, False} such
    that f - Dg is in k if b == True, or f - Dg does not have an
    elementary integral over k(t) if b == False.

    This function returns a Basic expression.
    """
    t = T[-1]
    z = Symbol('z', dummy=True)
    g1, h, r = hermite_reduce(a, d, D, x, T)
    g2, b = residue_reduce(h[0], h[1], D, x, T, z=z)
    if not b:
        return ((g1[0].as_basic()/g2[1].as_basic()).subs(reversed(zip(T, [f(x)
            for x in Tfuncs]))) + residue_reduce_to_basic(g2, t, z, tfunc))

    # Because f has no specials, this should be a polynomial in t, or else
    # there is a bug.
    p = cancel(h[0].as_basic()/h[1].as_basic() - residue_reduce_derivation(g2,
        D, x, T, z).as_basic() + r[0].as_basic()/r[1].as_basic()).as_poly(t)
    q1, q2 = polynomial_reduce(p, D, x, T)

    if q2.has(t):
        b = False
    else:
        b = True

    ret = cancel(g1[0].as_basic()/g1[1].as_basic() + q1.as_basic()).subs(
        reversed(zip(T, [f(x) for f in Tfuncs]))) + residue_reduce_to_basic(g2,
        x, T, z, Tfuncs)
    return (ret, b)
